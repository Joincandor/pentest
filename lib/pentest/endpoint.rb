require 'pentest/checkers'

module Pentest
  class Endpoint
    attr_reader :route, :app_path

    def initialize(route, app_path)
      @route = route
      @app_path = app_path

      @controller = route.defaults[:controller]
      @action = route.defaults[:action]

      return if @controller.nil? || @action.nil?

      @controller_name = ::ActiveSupport::Inflector.camelize(@controller) + "Controller"
      @controller_class = ::ActiveSupport::Inflector.constantize(@controller_name)

      @error_patterns = Set.new
    end

    def valid?
      !@controller.nil? && !@action.nil? && @controller_class.method_defined?(@action.to_sym)
    end

    def scan!
      params = get_params

      Logger.info "#{@route.verb} #{path}"
      Logger.debug "Attacking #{@controller_class.inspect}##{@action}...", timestamp: false
      Logger.debug "Detected Parameters: #{params.to_a.inspect}", timestamp: false

      error_patterns = Set.new
      penetrated_payloads = []

      Checkers.run_checkers(self) do |checker|
        Logger.start_progress

        params.each_with_index do |param, injection_point|
          # preattack
          preattack_payloads = checker.generate_preattack_payloads(params, %w(hoge fuga piyo foo bar baz), injection_point)

          checker.before_preattack

          penetrated_payload = nil
          preattack_payloads.shuffle.each do |payload|
            request, response, err = dispatch(payload)
            status = err.nil? ? response.status : 500
            Logger.put_progress (status / 100).to_s

            accumulate_error err, payload

            checker.check_preattack_result(payload, err);

            unless payload.penetration_confidence.nil?
              penetrated_payload = payload
              break
            end
          end

          checker.after_preattack

          # preattack not succeeded. skipping
          next if penetrated_payload.nil?

          # attack
          attack_payloads = checker.generate_attack_payloads(params, penetrated_payload.values, injection_point)

          checker.before_attack

          attack_payloads.shuffle.each do |payload|
            request, response, err = dispatch(payload)
            status = err.nil? ? response.status : 500
            Logger.put_progress (status / 100).to_s

            accumulate_error err, payload

            checker.check_attack_result(payload, err);

            if payload.penetration_confidence == :attack
              penetrated_payload = payload
              break
            end
          end

          checker.after_attack

          penetrated_payloads << penetrated_payload
        end
      end

      Logger.end_progress

      @error_patterns.each do |error_pattern|
        Logger.warn(error_pattern, timestamp: false)
      end

      penetrated_payloads
    end

    private

    def method
      @controller_class.instance_method(@action.to_sym)
    end

    def path(options = {})
      @route.required_parts.each do |part|
        options[part] ||= ":#{part}"
      end

      @route.format(options)
    end

    def get_params
      exp = RubyParser.get_sexp(method)
      param_usages = AstUtils.search_for_params(exp)
      deep_parameters = Set.new
      non_deep_parameters = Set.new

      param_usages.each do |param, type, method, arg|
        if type == :callee && method == :[]
          deep_parameters << [ param, arg[1] ]
        else
          non_deep_parameters << param
        end
      end

      non_deep_parameters += @route.required_parts.map(&:to_sym)
      non_deep_parameters -= deep_parameters.map {|a| a[0]}
      deep_parameters.to_a + non_deep_parameters.map {|param| [param]}
    end

    def accumulate_error(err, payload)
      return if err.nil?
      
      message = err.message.lines.first.strip
      payload.params_hash.values.sort_by(&:size).reverse.each do |param|
        message = message.gsub(param.inspect, '"[parameter]"')
        if param.size >= 4
          message = message.gsub(param, '[parameter]')
        end
      end

      @error_patterns << message
    end

    def dispatch(payload)
      request = ActionDispatch::TestRequest.create
      request.request_method = @route.verb
      request.path = path(payload.params_hash)

      # TODO: Use user-customized hook
      request.session[:user_id] = User.first.id

      request.path_parameters = {
        controller: @controller,
        action: @action,
      }

      payload.params_hash.each do |param_parts, value|
        if param_parts.size == 1
          param, = param_parts
          if @route.required_parts.include? param
            request.path_parameters[param] = value
          else
            request.query_parameters[param] = value
          end
        elsif param_parts.size == 2
          request.query_parameters[param_parts[0]] ||= {}
          request.query_parameters[param_parts[0]][param_parts[1]] = value
        end
      end

      request.path_parameters.each do |param, value|
        request.update_param(param, value)
      end

      request.query_parameters.each do |param, value|
        request.update_param(param, value)
      end

      response = ActionDispatch::TestResponse.create

      err = nil
      begin
        @controller_class.new.dispatch(@action.to_sym, request, response)
      rescue => e
        err = e
      end

      [request, response, err]
    end
  end
end