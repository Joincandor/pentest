require 'pentest/checkers/base_checker'
require 'pentest/payload'
require 'pentest/sql_proxy'
require 'pairwise'
require 'arproxy'
require 'gda'

class Pentest::SqliChecker < Pentest::BaseChecker
  Pentest::Checkers.add self

  @description = "Checks for SQL injections"

  SQLI_PAYLOADS = File.read(File.expand_path('../fuzzers/sqli.txt', File.dirname(__FILE__))).lines.map(&:strip).select {|l| l.size > 5 && l =~ /\W/}
  CRACKER_PAYLOAD = %q(<>"'%;()&+)

  def initialize
    super
    @queries = []
    @parser = GDA::SQL::Parser.new
  end

  def generate_preattack_payloads(params, seeds, injection_point)
    values_list = if params.size - 1 <= 0
      [[]]
    elsif params.size - 1 == 1
      seeds.map {|s| [s]}
    else
      Pairwise.combinations(*([seeds] * (params.size - 1)))
    end

    values_list.map do |values|
      values.insert(injection_point, CRACKER_PAYLOAD)

      Pentest::Payload.new(
        params: params,
        values: values,
        injection_point: injection_point,
        injection: CRACKER_PAYLOAD,
      )
    end.take(50)
  end

  def before_preattack
    nil
  end

  def after_preattack
    nil
  end

  def check_preattack_result(payload, err)
    if ::ActiveRecord::StatementInvalid === err
      payload.penetration_confidence = :preattack
    end
  end

  def handle_query(sql)
    @queries << sql
  end

  def before_attack
    Pentest::SqlProxy.enable!(self.method(:handle_query))
  end

  def after_attack
    Pentest::SqlProxy.disable!(self.method(:handle_query))
  end

  def generate_attack_payloads(params, values, injection_point)
    SQLI_PAYLOADS.map do |injection|
      new_values = values.dup
      new_values[injection_point] = injection

      Pentest::Payload.new(
        params: params,
        values: new_values,
        injection_point: injection_point,
        injection: injection,
      )
    end
  end

  def check_attack_result(payload, err)
    pp @queries
    if ::ActiveRecord::StatementInvalid === err
      penetrated = true
    end
  end
end