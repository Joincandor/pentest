require 'pentest/checkers/base_checker'
require 'pentest/payload'
require 'pentest/sql_proxy'
require 'term/ansicolor'
require 'pairwise'
require 'arproxy'
require 'gda'

class Pentest::SqliChecker < Pentest::BaseChecker
  Pentest::Checkers.add self

  @description = "Checks for SQL injections"

  SQLI_PAYLOADS = File.read(File.expand_path('../fuzzers/sqli.txt', File.dirname(__FILE__))).lines.map(&:strip).select {|l| l.size > 5 && l =~ /\W/}
  CRACKER_PAYLOAD = %q(<>"'%;()&+)

  def initialize
    super
    @queries = []
    @parser = GDA::SQL::Parser.new
  end

  def generate_preattack_payloads(params, seeds, injection_point)
    values_list = if params.size - 1 <= 0
      [[]]
    elsif params.size - 1 == 1
      seeds.map {|s| [s]}
    else
      Pairwise.combinations(*([seeds] * (params.size - 1)))
    end

    values_list.map do |values|
      values.insert(injection_point, CRACKER_PAYLOAD)

      Pentest::Payload.new(
        params: params,
        values: values,
        injection_point: injection_point,
        injection: CRACKER_PAYLOAD,
      )
    end.take(50)
  end

  def before_preattack
    nil
  end

  def after_preattack
    nil
  end

  def check_preattack_result(payload, err)
    if ::ActiveRecord::StatementInvalid === err
      payload.penetration_confidence = :preattack
    end
  end

  def handle_query(sql)
    @queries << sql
  end

  def before_attack
    Pentest::SqlProxy.enable!(self.method(:handle_query))
  end

  def after_attack
    Pentest::SqlProxy.disable!(self.method(:handle_query))
  end

  def generate_attack_payloads(params, values, injection_point)
    SQLI_PAYLOADS.map do |injection|
      new_values = values.dup
      new_values[injection_point] = injection

      Pentest::Payload.new(
        params: params,
        values: new_values,
        injection_point: injection_point,
        injection: injection,
      )
    end
  end

  def check_attack_result(payload, err)
    @queries.each do |query|
      begin
        stmt = @parser.parse(query.tr('`?', '"0'))
      rescue RuntimeError => e
        next
      end

      if query.include?(payload.injection) && !(GDA::Nodes::Unknown === stmt.ast)
        tokens = extract_values(stmt.ast)
        if tokens.all? {|token| !token.force_encoding("UTF-8").include? payload.injection}
          payload.penetration_confidence = :attack
          payload.penetration_message = "Detected query: #{query.gsub(payload.injection, Term::ANSIColor.red(payload.injection))}"
          break
        end
      end
    end
  end

  def extract_values(stmt)
    ret = []

    if stmt.nil?
      # nop
    elsif stmt.is_a?(String)
      ret << stmt
    elsif stmt.is_a?(Integer)
      ret << stmt.to_s
    elsif stmt.is_a?(Array)
      stmt.each do |s|
        ret += extract_values(s)
      end
    elsif GDA::Nodes::Table === stmt
      ret += extract_values(stmt.table_name)
    elsif GDA::Nodes::Field === stmt
      ret += extract_values(stmt.field_name)
    elsif GDA::Nodes::Expr === stmt
      ret += extract_values(stmt.func)
      ret += extract_values(stmt.cond)
      ret += extract_values(stmt.select)
      ret += extract_values(stmt.case_s)
      ret += extract_values(stmt.param_spec)
      ret += extract_values(stmt.cast_as)
      ret << stmt.value
    elsif GDA::Nodes::Select === stmt
      ret += extract_values(stmt.distinct_expr)
      ret += extract_values(stmt.expr_list)
      ret += extract_values(stmt.from)
      ret += extract_values(stmt.where_cond)
      ret += extract_values(stmt.group_by)
      ret += extract_values(stmt.having_cond)
      ret += extract_values(stmt.order_by)
      ret += extract_values(stmt.limit_count)
      ret += extract_values(stmt.limit_offset)
    elsif GDA::Nodes::SelectField === stmt
      ret += extract_values(stmt.expr)
      ret += extract_values(stmt.field_name)
      ret += extract_values(stmt.table_name)
      ret += extract_values(stmt.as)
    elsif GDA::Nodes::From === stmt
      ret += extract_values(stmt.targets)
      ret += extract_values(stmt.joins)
    elsif GDA::Nodes::Operation === stmt
      ret += extract_values(stmt.operands)
    elsif GDA::Nodes::Target === stmt
      ret += extract_values(stmt.expr)
      ret += extract_values(stmt.table_name)
      ret += extract_values(stmt.as)
    elsif GDA::Nodes::Function === stmt
      ret += extract_values(stmt.args_list)
      ret += extract_values(stmt.function_name)
    elsif GDA::Nodes::Order === stmt
      ret += extract_values(stmt.expr)
      ret += extract_values(stmt.collation_name)
    elsif GDA::Nodes::Insert === stmt
      ret += extract_values(stmt.table)
      ret += extract_values(stmt.fields_list)
      ret += extract_values(stmt.expr_list)
      ret += extract_values(stmt.cond)
      ret += extract_values(stmt.conflict)
    elsif GDA::Nodes::Delete === stmt
      ret += extract_values(stmt.table)
      ret += extract_values(stmt.cond)
    elsif GDA::Nodes::Join === stmt
      ret += extract_values(stmt.expr)
      ret += extract_values(stmt.use)
      ret += extract_values(stmt.position)
    elsif GDA::Nodes::Compound === stmt
      ret += extract_values(stmt.compound_type)
    elsif GDA::Nodes::Unknown === stmt
      ret += extract_values(stmt.expressions)
    end

    ret
  end
end